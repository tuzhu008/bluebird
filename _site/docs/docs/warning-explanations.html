<p><a href="unfinished-article">warning-explanations</a></p>

<ul>
  <li><a href="#warning-then-only-accepts-functions">Warning: .then() only accepts functions</a></li>
  <li><a href="#warning-a-promise-was-rejected-with-a-non-error">Warning: a promise was rejected with a non-error</a></li>
  <li><a href="#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it">Warning: a promise was created in a handler but was not returned from it</a></li>
</ul>

<p>Note - in order to get full stack traces with warnings in Node 6.x+ you need to enable to <code class="highlighter-rouge">--trace-warnings</code> flag which will give you a full stack trace of where the warning is coming from.</p>

<h2 id="warning-then-only-accepts-functions">Warning: .then() only accepts functions</h2>

<p>If you see this warning your code is probably not doing what you expect it to, the most common reason is passing the <em>result</em> of calling a function to <a href=".">.then()</a> instead of the function <em>itself</em>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">processImage</span><span class="p">(</span><span class="nx">image</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Code that processes image</span>
<span class="p">}</span>

<span class="nx">getImage</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">processImage</span><span class="p">());</span>
</code></pre></div></div>

<p>The above calls the function <code class="highlighter-rouge">processImage()</code> <em>immediately</em> and passes the result to <a href=".">.then()</a> (which is most likely <code class="highlighter-rouge">undefined</code> - the default return value when a function doesn’t return anything).</p>

<p>To fix it, simply pass the function reference to <a href=".">.then()</a> as is:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getImage</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="nx">processImage</span><span class="p">)</span>
</code></pre></div></div>

<p><em>If you are wondering why this is a warning and not a simple TypeError it is because the due to historic reasons Promises/A+ specification requires that incorrect usage is silently ignored.</em></p>

<h2 id="warning-a-promise-was-rejected-with-a-non-error">Warning: a promise was rejected with a non-error</h2>

<p>Due to a historic mistake in JavaScript, the <code class="highlighter-rouge">throw</code> statement is allowed to be used with any value, not just errors, and Promises/A+ choosing to inherit this mistake, it is possible to reject a promise with a value that is not an error.</p>

<p>An error is an object that is a <code class="highlighter-rouge">instanceof Error</code>. It will at minimum have the properties <code class="highlighter-rouge">.stack</code> and <code class="highlighter-rouge">.message</code>, which are an absolute <em>must</em> have for any value that is being used in an automatic propagation mechanism, such as exceptions and rejections. This is because errors are usually handled many levels above where they actually originate - the error object must have sufficient metadata about it so that its ultimate handler (possibly many levels above) will have all the information needed for creating a useful high level error report.</p>

<p>Since all objects support having properties you might still wonder why exactly does it have to be an error object and not just any object. In addition to supporting properties, an equally important feature necessary for values that are automatically propagated is the stack trace property (<code class="highlighter-rouge">.stack</code>). A stack trace allows you easily find where an error originated from as it gives the code’s call stack - along with line numbers for reference in code files.</p>

<p>You should heed this warning because rejecting a promise with a non-error makes debugging extremely hard and costly. Additionally, if you reject with simple primitives such as <code class="highlighter-rouge">undefined</code> (commonly caused by simply calling <code class="highlighter-rouge">reject()</code>) you cannot handle errors at all because it’s impossible to tell from <code class="highlighter-rouge">undefined</code> what exactly went wrong. All you can tell the user is that “something went wrong” and lose them forever.</p>

<h2 id="warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it">Warning: a promise was created in a handler but was not returned from it</h2>

<p>This usually means that you simply forgot a <code class="highlighter-rouge">return</code> statement somewhere, which will cause a runaway promise that is not connected to any promise chain.</p>

<p>For example:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getUser</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">getUserData</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">userData</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// userData is undefined</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Because the result of <code class="highlighter-rouge">getUserData()</code> is not returned from the first then handler, it becomes a runaway promise that is not awaited for by the second then. The second <a href=".">.then()</a> simply gets immediately called with <code class="highlighter-rouge">undefined</code> (because <code class="highlighter-rouge">undefined</code> is the default return value when you don’t return anything).</p>

<p>To fix it, you need to <code class="highlighter-rouge">return</code> the promise:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getUser</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">getUserData</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">userData</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// userData is the user's data</span>
<span class="p">});</span>
</code></pre></div></div>

<hr />

<p>If you know what you’re doing and don’t want to silence all warnings, you can create runaway promises without causing this warning by returning e.g. <code class="highlighter-rouge">null</code>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getUser</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Perform this in the "background" and don't care about its result at all</span>
    <span class="nx">saveAnalytics</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
    <span class="c1">// return a non-undefined value to signal that we didn't forget to return</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

